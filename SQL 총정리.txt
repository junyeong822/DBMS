sqld(sql 개발자)
- 데이터베이스에 관한 이론
- sql 쿼리(실습)
- 실기 X
- 데이터모델의 이해 및 분석(이론)
- SQL 이해 및 활용(실습)

정보처리 자격증
- 컴퓨터에 대한 기본적인 지식(HW 포함)
- 프로그래밍 언어(C, Java, Python)에 대한 지식
- 데이터베이스(sql 포함)
- 1) 소프트웨어 설계
- 2) 소프트웨어 개발
- 3) 데이터베이스 구축
- 4) 프로그래밍 언어 활용(sql 포함)
- 5) 정보 시스템 구축 관리(보안)

1. 데이터 모델링
- 추상화(세부적인 건 배제, 핵심만 도출)
- 점점 상세하게 설계

특징
- 추상화 : 간략하게 표현, 핵심만 표현
- 단순화 : 쉽게 이해 가능하게 표현, 복잡하게 X
- 명확성 : 모호하지 않게 표현, 명확한 해석이 가능하게 표현

단계
- 개념적 데이터 모델링 : ERD 작성, 추상화 수준이 가장 높음
- 논리적 데이터 모델링 : 테이블 명세서 작성, 추상화 수준이 중간 정도
- 물리적 데이터 모델링 : 구현, 추상화 수준이 가장 낮음

관점
- 데이터 : 비즈니스에서 사용되는 데이터
- 프로세스 : 비즈니스에서 수행되는 작업
- 데이터와 프로세스 : 데이터-프로세스 간의 관계

ERD 작성 절차
- 1. 엔티티 도출 및 그림
- 2. 엔티티 배치
- 3. 엔티티 간 관계 설정
- 4. 관계명 서술
- 5. 관계 참여도 표현
- 6. 관계 필수여부 표현

3층 스키마
- 외부 : 사용자 관점
- 개념 : 조직과 설계자 관점
- 내부 : 하드웨어와 개발자 관점

데이터 독립성
- 논리적 : 개념 스키마 변경돼도 외부 스키마 영향 X
- 물리적 : 내부 스키마 변경돼도 개념 스키마 영향 X

식별자
- 유일성을 만족하는 속성

키
- 기본키 : 개체를 대표하는 키, 유일성과 최소성을 만족
- 후보키 : 유일성과 최소성을 만족
- 슈퍼키 : 유일성만 만족
- 대체키 : 후보키 중 기본키가 되지 못한 키, 유일성과 최소성을 만족

유일성 : 개체를 유일하게 식별
최소성 : 최소의 속성으로 구성

외래키
- 다른 테이블의 기본키 필드
- 참조 무결성 제약조건을 확인하기 위해 사용되는 키

식별자 종류(대표성 여부)
- 주 식별자 : 개체를 대표, 대표성 만족
- 보조 식별자 : 대표성을 만족하지 못함

(생성 여부)
- 내부 식별자 : 개체 내부에서 스스로 생성
- 외부 식별자 : 다른 개체와의 관계로 인해 생성

(속성의 수)
- 단일 식별자 : 1개의 속성
- 복합 식별자 : 2개 이상의 속성

(대체 여부)
- 본질 식별자 : 비즈니스에서 생성
- 인조 식별자 : 인위적으로 생성

정규화
- 두부이걸다줘?
- 1정규화 : 도메인 원자값
- 2정규화 : 부분 함수적 종속 제거
- 3정규화 : 이행 함수적 종속 제거
- BCNF : 결정자가 후보키가 아닌 것 제거
- 4정규화 : 다치 종속 제거
- 5정규화 : 조인 종속 제거
- 도부이결다조

반정규화
- 조회 성능 향상을 위해 사용

기법
- 계산된 속성 추가
- 테이블 수직 분할
- 테이블 수평 분할
- 테이블 병합

분산 데이터베이스
- 논리적으로 하나이지만 물리적으로는 여러 곳에 존재

투명성
- 위치 투명성 : 저장 장소 명시 X
- 중복 투명성 : 여러 시스템에 중복돼도 일관성 유지
- 장애 투명성 : 장애 생겨도 무결성 보장
- 병행 투명성 : 여러 트랜잭션 수행에도 결과 이상 X

트랜잭션
- 데이터베이스의 연산 단위

특징
- 원자성 : 전부 실행 OR 전혀 실행 X
- 일관성 : 실행 후 일관성 유지
- 독립성 : 다른 트랜잭션이 연산 참여 X
- 영속성 : 결과를 영구적 보장

DDL
- CRAETE, ALTER, DROP, RENAME
DML
- INSERT, UPDATE, SELECT, DELETE
DCL
- GRANT, REVOKE, TRUNCATE
TCL
- COMMIT, ROLLBACK, SAVEPOINT

옵티마이저
- SQL 최적화 용도
- 개발자가 SQL 작성 --> 옵티마이저가 실행 계획을 수립하고 SQL 실행
- 힌트(HINT) : 개발자가 옵티마이저에게 실행 방법을 알려주는 것
- 최저비용을 목표

종류
- 규칙기반 : 15개 우선순위를 기준
- 비용기반 : 소요시간 OR 자원사용량

인덱스
- 빠르게 조회할 수 있게 도와주는 역할

특징
- 키로 정렬
- 하나의 테이블에 여러개의 인덱스 가능
- 테이블 생성시, 자동으로 기본키 --> 인덱스

CASCADE
- 참조 관계(PK - FK)가 있을 경우 자동 반영, 연쇄 작용
- 참조 무결성 준수

뷰
- 가상 테이블
- 기존의 테이블로부터 유도된 가상의 테이블
- 실제 데이터 X
- 기존 테이블을 참조해 원하는 형식의 데이터를 조회할 수 있게 도와줌
- 삽입, 수정, 삭제 연산에 제약이 있음

차수
- 속성의 수

카디널리티
- 튜플의 수

도메인
- 속성들이 가질 수 있는 값들의 집합

스키마
- 속성 + 도메인
- 데이터베이스 구조와 제약조건

병행제어
- 로킹(Locking)
- 타임스탬프(Time Stamp)

로킹
- 특정 범위를 잠금 --> 다른 트랜잭션이 접근할 수 없게함
- 로킹 단위는 속성, 튜플, 테이블, 데이터베이스 등.. 모두 로킹 단위 가능
- 로킹 단위가 크면 : 오버헤드 감소(연산이 적어짐), 동시성 수준 감소(병행 수행이 원활히 되는가)
- 로킹 단위가 작으면 : 오버헤드 증가(연산이 많아짐), 동시성 수준 증가

타임스탬프
- 특정 범위에 접근하는 시간을 미리 정해서 순서대로 접근

함수적 종속성
- X --> Y
- X : 결정자
- Y : 종속자
- 속성 값 X에 의해 속성 값 Y가 달라지는 경우 Y는 X에 함수적 종속이라고 함

완전 함수적 종속
- 종속자가 기본키에만 종속

부분 함수적 종속
- 종속자가 기본키가 아닌 기본키를 구성하는 속성 중 일부에 종속

이행 함수적 종속
- X --> Y
- Y --> Z
- X --> Z 가 성립되는 경우

데이터 무결성
- 데이터의 정확성, 일관성, 유효성이 유지되는 것

개체 무결성
- 기본키에는 Null 값이 올 수 없고, 오직 하나의 값만 존재해야 한다.

참조 무결성
- 외래키의 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 한다.

도메인 무결성
- 릴레이션 내부에 존재하는 속성의 타입, 옵션 등..에 대한 사항의 정의하고 올바른 데이터가 입력되었는지 확인하는 조건

Null 무결성
- 테이블의 특정 속성 값이 Null이 될 수 없게하는 조건

고유 무결성
- 테이블의 특정 속성 값이 서로 달라야 하는 조건

키 무결성
- 테이블에 적어도 하나의 키가 존재해야 한다는 조건

관계 무결성
- 테이블의 레코드 삽입 가능 여부 또는 레코드들 사이의 관계에 대한 적절성 여부를 지정한 조건

속성 분류
- 기본 속성 : 업무로부터 추출한 속성
- 설계 속성 : 데이터 모델링 중 속성을 새로 만들거나 변형하여 정의하는 속성
- 파생 속성 : 다른 속성에 영향을 받아 발생하는 속성

관계 대수
- 절차적 언어 문법
- DML
- 기존의 릴레이션들로부터 새로운 릴레이션을 생성

관계 해석
- 비절차적 언어
- 원하는 데이터가 무엇인지만